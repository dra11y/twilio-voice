use serde::{Deserialize, Serialize};

use crate::twiml::Digits;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum CallStatus {
    /// The call is ready and waiting in line before going out.
    Queued,

    /// The call is currently ringing.
    Ringing,

    /// The call was answered and is actively in progress.
    InProgress,

    /// The call was answered and has ended normally.
    Completed,

    /// The caller received a busy signal.
    Busy,

    /// The call could not be completed as dialed, most likely because the phone number was non-existent.
    Failed,

    /// The call ended without being answered.
    NoAnswer,

    /// The call was canceled via the REST API while queued or ringing.
    Canceled,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum Direction {
    /// inbound calls
    Inbound,

    /// calls initiated via the REST API
    OutboundApi,

    /// calls initiated by a <Dial> verb
    OutboundDial,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
// #[cfg_attr(feature = "axum", derive(axum_macros::FromRequest))]
#[serde(rename_all = "PascalCase")]
pub struct Request {
    /// A unique identifier for this call, generated by Twilio.
    pub call_sid: String,

    /// Your Twilio account ID. It is 34 characters long, and always starts with the letters AC.
    pub account_sid: String,

    /// The phone number or client identifier of the party that initiated the call. Phone numbers are formatted with a '+' and country code, e.g., +16175551212 (E.164 format). Client identifiers begin with the client: URI scheme; for example, on a call from a client named 'charlie', the From parameter will be client:charlie. If a caller ID is withheld or otherwise unavailable, you may receive a string that contains anonymous, unknown, or other descriptions.
    pub from: String,

    /// The phone number or client identifier of the called party. Phone numbers are formatted with a '+' and country code, e.g., +16175551212(E.164 format). Client identifiers begin with the client: URI scheme; for example, for a call to a client named 'joey', the To parameter will be client:joey.
    pub to: String,

    /// Any digits dialed by the caller in response to a <Gather>. Excludes the digit of the `finishOnKey` <Gather> parameter. Empty if no digits were entered.
    #[serde(default)]
    pub digits: Digits,

    /// A descriptive status for the call. See [`CallStatus`].
    pub call_status: CallStatus,

    /// The version of the Twilio API used to handle this call. For incoming calls, this is determined by the API version set on the called number. For outgoing calls, this is the version used by the REST API request from the outgoing call.
    pub api_version: String,

    /// A string describing the direction of the call: inbound for inbound calls outbound-api for calls initiated via the REST API outbound-dial for calls initiated by a <Dial> verb.
    pub direction: Direction,

    /// This parameter is set only when Twilio receives a forwarded call, but its value depends on the caller's carrier including information when forwarding. Not all carriers support passing this information.
    pub forwarded_from: Option<String>,

    /// This parameter is set when the IncomingPhoneNumber that received the call has had its VoiceCallerIdLookup value set to true.
    pub caller_name: Option<String>,

    /// A unique identifier for the call that created this leg. This parameter is not passed if this is the first leg of a call.
    pub parent_call_sid: Option<String>,

    /// A token string needed to invoke a forwarded call.
    pub call_token: Option<String>,

    /// The city of the caller
    pub from_city: Option<String>,

    /// The state or province of the caller
    pub from_state: Option<String>,

    /// The postal code of the caller
    pub from_zip: Option<String>,

    /// The country of the caller
    pub from_country: Option<String>,

    /// The city of the called party
    pub to_city: Option<String>,

    /// The state or province of the called party
    pub to_state: Option<String>,

    /// The postal code of the called party
    pub to_zip: Option<String>,

    /// The country of the called party
    pub to_country: Option<String>,
}

#[cfg(test)]
mod tests {
    use crate::{
        errors::{DigitsError, Error},
        twiml::Digit,
    };

    use super::*;

    #[test]
    fn test_deserialize_request() {
        let digits = "31#*";
        let params = format!(
            "Digits={digits}&CallSid=4321abcdef0&AccountSid=5678feabcd1&ApiVersion=2010&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress"
        );
        let req: Request =
            serde_urlencoded::de::from_str(&params).expect("failed to deserialize Request");
        assert_eq!(req.digits.to_string(), digits);
        assert_eq!(req.digits.iter().last(), Some(&Digit::Star));
        let number = req.digits.to_int();
        assert_eq!(number.unwrap(), 31);
        assert_eq!(req.call_sid, "4321abcdef0");
        assert_eq!(req.account_sid, "5678feabcd1");
        assert_eq!(req.api_version, "2010");
        assert_eq!(req.direction, Direction::Inbound);
        assert_eq!(req.to, "+12125551234");
        assert_eq!(req.from, "+19193332345");
        assert_eq!(req.call_status, CallStatus::InProgress);
    }

    #[test]
    fn test_call_status_deserialization() {
        // Test all CallStatus variants through the Request struct
        for (status_str, status_enum) in [
            ("queued", CallStatus::Queued),
            ("ringing", CallStatus::Ringing),
            ("in-progress", CallStatus::InProgress),
            ("completed", CallStatus::Completed),
            ("busy", CallStatus::Busy),
            ("failed", CallStatus::Failed),
            ("no-answer", CallStatus::NoAnswer),
            ("canceled", CallStatus::Canceled),
        ] {
            let params = format!(
                "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus={status_str}"
            );
            let req: Request = serde_urlencoded::from_str(&params).unwrap();
            assert_eq!(req.call_status, status_enum);
        }
    }

    #[test]
    fn test_direction_deserialization() {
        // Test all Direction variants through the Request struct
        for (direction_str, direction_enum) in [
            ("inbound", Direction::Inbound),
            ("outbound-api", Direction::OutboundApi),
            ("outbound-dial", Direction::OutboundDial),
        ] {
            let params = format!(
                "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction={direction_str}&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress"
            );
            let req: Request = serde_urlencoded::from_str(&params).unwrap();
            assert_eq!(req.direction, direction_enum);
        }
    }

    #[test]
    fn test_request_with_optional_fields() {
        let params = "CallSid=abc123&AccountSid=AC123456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress&FromCity=Raleigh&FromState=NC&FromZip=27601&FromCountry=US&ToCity=New+York&ToState=NY&ToZip=10001&ToCountry=US&ForwardedFrom=%2B18005551212&CallerName=John+Doe&ParentCallSid=CAparent123&CallToken=token123";

        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // Optional fields
        assert_eq!(req.from_city, Some("Raleigh".to_string()));
        assert_eq!(req.from_state, Some("NC".to_string()));
        assert_eq!(req.from_zip, Some("27601".to_string()));
        assert_eq!(req.from_country, Some("US".to_string()));
        assert_eq!(req.to_city, Some("New York".to_string()));
        assert_eq!(req.to_state, Some("NY".to_string()));
        assert_eq!(req.to_zip, Some("10001".to_string()));
        assert_eq!(req.to_country, Some("US".to_string()));
        assert_eq!(req.forwarded_from, Some("+18005551212".to_string()));
        assert_eq!(req.caller_name, Some("John Doe".to_string()));
        assert_eq!(req.parent_call_sid, Some("CAparent123".to_string()));
        assert_eq!(req.call_token, Some("token123".to_string()));
    }

    #[test]
    fn test_request_without_optional_fields() {
        let params = "CallSid=abc123&AccountSid=AC123456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress";

        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // Optional fields should be None
        assert_eq!(req.from_city, None);
        assert_eq!(req.from_state, None);
        assert_eq!(req.from_zip, None);
        assert_eq!(req.from_country, None);
        assert_eq!(req.to_city, None);
        assert_eq!(req.to_state, None);
        assert_eq!(req.to_zip, None);
        assert_eq!(req.to_country, None);
        assert_eq!(req.forwarded_from, None);
        assert_eq!(req.caller_name, None);
        assert_eq!(req.parent_call_sid, None);
        assert_eq!(req.call_token, None);
    }

    #[test]
    fn test_empty_digits() {
        let params = "Digits=&CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress";
        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // Check empty digits
        assert!(req.digits.is_empty());
        assert_eq!(req.digits.to_string(), "");
        assert!(matches!(
            req.digits.to_int(),
            Err(Error::Digits(DigitsError::Empty))
        ));
    }

    #[test]
    fn test_missing_digits() {
        // Test when Digits parameter is entirely missing
        let params = "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress";
        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // Digits should be empty when parameter is missing
        assert!(req.digits.is_empty());
    }

    #[test]
    fn test_malformed_request() {
        // Test with missing required fields
        let params = "CallSid=CA123"; // Missing most required fields
        let result = serde_urlencoded::from_str::<Request>(params);
        assert!(result.is_err());

        // Test with invalid enum value
        let params = "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=invalid&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress";
        let result = serde_urlencoded::from_str::<Request>(params);
        assert!(result.is_err());

        // Test with invalid call status
        let params = "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=not-a-status";
        let result = serde_urlencoded::from_str::<Request>(params);
        assert!(result.is_err());
    }

    #[test]
    fn test_url_encoded_characters() {
        // Test with URL-encoded special characters in fields
        let params = "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress&CallerName=John%20Doe%20%26%20Family";
        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // Check the decoded special characters
        assert_eq!(req.caller_name, Some("John Doe & Family".to_string()));
    }

    #[test]
    fn test_plus_decoded_as_space() {
        // Test that + in URL-encoded data is decoded as space
        let params = "CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress&CallerName=John+Doe";
        let req: Request = serde_urlencoded::from_str(params).unwrap();

        // + should be decoded as space
        assert_eq!(req.caller_name, Some("John Doe".to_string()));
    }

    #[test]
    fn test_complex_digits() {
        // Test with various digit combinations
        let test_cases = [
            ("123", Some(123)),
            ("456#", Some(456)),
            ("789*", Some(789)),
            ("0*#", Some(0)),
            ("0A*#", None),
            ("*123", None),  // Starts with *, can't convert to int
            ("#456", None),  // Starts with #, can't convert to int
            ("12*34", None), // can't convert to int
            ("56#78", None), // can't convert to int
            ("*#", None),    // No digits to convert
        ];

        for (digit_str, expected_int) in test_cases {
            let params = format!(
                "Digits={digit_str}&CallSid=CA123&AccountSid=AC456&ApiVersion=2010-04-01&Direction=inbound&To=%2B12125551234&From=%2B19193332345&CallStatus=in-progress"
            );
            let req: Request = serde_urlencoded::from_str(&params).unwrap();

            assert_eq!(req.digits.to_string(), digit_str);
            assert_eq!(req.digits.to_int().ok(), expected_int);
        }
    }
}
